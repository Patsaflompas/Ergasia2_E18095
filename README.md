# Ergasia2_E18095
Ergasia 2 Plhroforiaka Susthmata

Οδηγίες Χρήσης:
Πριν μπουμε στα βαθια, πρέπει να εγκαταστήσετε το docker και να βρείτε κάποιο τέρμιναλ που να δεχεται εντολες linux όπως το windows powershell με κάποια downloads,google that.
Για να εκτελεστεί το web service στον υπολογιστή σας, αρκεί να κατεβάσετε τα αρχεία docker-compose.yml και τον φάκελο flask(ο οποίος περιέχει το dockerfile του flask image, το αρχείο 2ndergasia.py που είναι ο κώδικας για την σύνδεση του flask με το pymongo και τις λειτουργίες του ΠΣ και εναν φάκελο data που δεν ξέρω αν είναι απαραίτητος αλλά έβαλα μέσα κάποια json για το collection users και products για την καλή αρχη). 
Όταν κατεβάσετε τα αρχεία, βάλτε τα σε έναν φάκελο, ανοίξτε κάποιο terminal που να υποστηρίζει εντολές docker, τοποθετήστε το directory σας εκεί με cd και με την εντολη
docker-compose up -d θα κατέβουν και τα images και θα τρέξει το container, έτοιμο να δεχτεί εντολές απο το postman, γιατι μόνο το postman ξερω να χειριζομαι για http methods 
και σας το συνιστώ :(, μην δοκιμασετε browser, δεχεται μονο get method δυστυχως.
Για να σταματήσει να τρέχει το service αρκεί να δώσετε την εντολη docker-compose down.

Περιγραφή λειτουργιών του συστηματός μου:

Πριν αρχίσω να πω οτι δεν έχω φτιάξει endpoint για δημιουργία διαχειριστή γιατι η εκφώνηση φαινόταν να μας περιορίζει σε plain user οπότε για να μπεί κάποιος σαν admin πρέπει να 
πειράξει απευθείας την MongoDB βάση μας και να κάνει insert_one, συγνώμη αν θέλατε να φτιάξουμε τρόπο register και login για admin :(

Στις γραμμές 50-71 έιναι το πρώτο endpoint το οποίο κάνει εγγραφή τον χρήστη αφού ελέγχει αν υπάρχει ήδη κάποιος άλλος με το ίδιο email, μέσω της count() που μετράει πόσα αρχεία
έχει η users με το email που δόθηκε, αν είναι 0 κάνουμε ένα λεξικο newUser το οποίο παίρνει τις τιμές του χρήστη και τον βάζουμε στο collection users, αλλιώς λέμε οτι υπάρχει ήδη.

Στις γραμμές 72-101 είναι το δεύτερο endpoint, το οποίο ψάχνει να βρει αν υπαρχει χρηστης με τα στοιχεια που δοθηκαν και αν ναι ελεγχει την κατηγορια του, αν ειναι plain user 
καλείται η create_user_session που δίνει ενα uuid στο λεξικο users_sessions και αν ειναι admin καλειται η create_admin_session και δινει ενα uuid στο λεξικο admin_sessions, μετα 
εκτυπωνει το uuid για να το χρησιμοποιήσει ο χρήστης στα headers των http request του έπειτα για εξουσιοδοτηση

Στις γραμμές 102-138 ειναι το τριτο endpoint, το οποίο δίνει την δυνατοτητα στον χρηστη να αναζητησει αντικειμενα μεσα στο collection products της βασης δεδομενων μας.
Απο αυτο το endpoint και μετα αρχιζει και η χρήση της is_user_Session_valid που ελεγχει αν το τρέχον uuid που δινει ο χρήστης βρίσκεται στο λεξικο users_sessions
δεν θα ξαναναφερθω στην is_users_session_valid
Για την αναζήτηση, ελέγχουμε τα δεδομενα που δινει ο χρηστης και αναλογα με αυτα ψάχνουμε με το κατάλληλο κριτηριο στην βάση μας, τα υλοποίησα με if "κατι" in data.
βάζω τα αποτελέσματα της find σε μια λιστα, ελέγχω αν ειναι άδεια, για να ξερω αν πρεπει να εμφανισω το κατάλληλο μηνυμα απογοητευσης και μετα εκτυπωνω την λιστα

γραμμές 144-186 προσθηκη αντικειμενων στο καλαθι του χρηστη:
αρχικά ελέγχουμε αν το stock του μαγαζιού φτάνει για να το βάλει στο καλάθι και το ενημερώνουμε κιολας πιο κατω με update_one και inc μειον το ποσο που παιρνει ο χρηστης το στοκ
φτιάχνω ενα βοηθητικο λεξικο με ονομα shoppingCartDummy για να περασω τις τιμες που δείνει ο χρήστης και τις ισαξιες απο την βαση και μετα αυτο το λεξικο το προσθετω σε μια 
λιστα με ονομα shoppingCart που ειναι και το καλαθι μας! 
Φτιαχνουμε επισης μια totalPrice και cartSum μεταβλητη για τον υπολογισμο του κοστους και την εμφανιση του μυνηματος μαζι με το κοστος αντιστοιχα.

στις γραμμες 187-201 δεν γινεται τιποτα ενδιαφερον, απλα ελεγχουμε αν το μηκος της λιστας του καλαθιου ειναι 0 και αν δεν ειναι το εμφανιζουμε,αν ειναι λεμε οτι ειναι αδειο στον χρηστη :(

στις γραμμες 202-245 γίνεται η διαγραφή αντικειμένων απο το καλάθι
μεσα σε μια for που τρεχει οσο και το μηκος της λιστας του καλαθιου, ελεγχει αν υπαρχει καπου καποιο αντικειμενο με id ιδιο με αυτο που ζητησε ο χρηστης να
διαγράψει και το διαγραφουμε, μαζι με την διαγραφη του αντικειμενου μειώνουμε και το κόστος του καλαθιού σύμφωνα με τα νεα δεδομένα αλλα και επιστρέφουμε στο stock του 
collection products τα αντικείμενα που είχε δεσμεύσει.

γραμμες 245-277 γίνεται η αγορα, μετατρέπουμε σε string τον 16ψηφιο κωδικο που εδωσε ο χρηστης για να μπορέσουμε να ελέγξουμε το μέγεθος του με μέθοδο len(), για να βεβαιωθούμε
οτι εδωσε 16 ψηφία και αρχικοποιώ μια μεταβλητη receipt η οποια του ανακοινωνει οτι ειναι η αποδειξη του και έχει μέσα της το καλάθι και το συνολικό κόστος, όπως και την 
ημερομηνια και ώρα που έγινε η αγορά, δικιά μου πινελιά αυτο, δεν το ζητησε κανεις.
μετα απο την εμφανιση γίνεται επισης η προσθηκη της αποδειξης receipt στο orderHistory του χρηστη στην βαση δεδομενων μας και η εκαθαριση της λιστας του καλαθιου και του 
συνολικου κοστους για να ειναι ετοιμες να παρουν νεες τιμες αν χρειαστει και αλλη αγορα ο χρηστης.

γραμμες 278-294 γινεται η εμφανιση του ιστορικου αγορων του χρηστη, απευθειας απο την mongodb με βαση τα στοιχεια που εκανε λογκιν.

γραμμες 296-311 γίνεται η διαγραφη του χρηστη και η εμφανιση των στοιχειων του πριν τον διαγραψουμε για να του ανακοινωσουμε οτι τον σβησαμε και ποιος ηταν για εμας, δημιουργώντας του τυψεις και ενοχες

γραμμές 312-341 γινεται η προσθηκη νεων προιοντων στη βαση μας απο τον διαχειριστη, αφου ελεγξει οτι δεν υπαρχει ηδη προιιον με ιδιο ονομα και το τυπωνουμε
έβαλα μια random.randint(100000,999999) για να δίνονται τυχαιοι 6ψηφιοι αριθμοι σαν id στα προιοντα αντι για το μακρυ string ObjectID που δινει η Mongo απο μονη της
για να ειναι πιο ευκολο στους χρηστες να αναζητησουν ενα προιον με 6 ψηφια ισα ισα, οχι τοσο μεγαλος αριθμος ωστε να σε κουραζει αλλα ουτε τοσο μικρος ετσι ωστε
να υπαρξει περιπτωση διπλοτυπιας σε καποιο προιον.

γραμμες 342-370 γινεται η διαγραφη ενος προιοντος απο την βαση μας με χαρακτηριστικο το id που δινει ο αντμιν, αν υπαρχει προιον με τετοιο id.

γραμμες 371-412 γινεται η ενημερωση. έχω βαλει 2 if in data με σκοπο να ειναι 100% απαραιτητο το id στα data αλλα οχι 100% απαραιτητα ΚΑΙ τα 4 υπολοιπα στοιχεια, 
name,stock,desc,price. Εδω μεσω πολλων if βλέπουμε τι θέλει να ενημερωσει ο διαχειριστης και με update_one και $set το ενημερωνουμε στο καταλληλο πεδίο και του εκτυπώνουμε
το νέο προιον

γραμμες 416-418 απλα τρεχουμε το flask σε debug mode επισης στην πορτα 5000

